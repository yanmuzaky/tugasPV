<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NuGet.Frameworks</name>
    </assembly>
    <members>
        <member name="T:NuGet.Frameworks.AssetTargetFallbackFramework">
            <summary>
            AssetTargetFallbackFramework only fallback when zero assets are selected. These do not 
            auto fallback during GetNearest as FallbackFramework would.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.AssetTargetFallbackFramework.Fallback">
            <summary>
            List framework to fall back to.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.AssetTargetFallbackFramework.RootFramework">
            <summary>
            Root project framework.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.AssetTargetFallbackFramework.AsFallbackFramework">
            <summary>
            Create a FallbackFramework from the current AssetTargetFallbackFramework.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkPrecedenceSorter">
            <summary>
            Sorts frameworks according to the framework mappings
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.NuGetFrameworkFullComparer">
            <summary>
            A case insensitive compare of the framework, version, and profile
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.NuGetFrameworkNameComparer">
            <summary>
            A case insensitive compare of the framework name only
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.NuGetFrameworkSorter">
            <summary>
            Sorts NuGet Frameworks in a consistent way for package readers.
            The order is not particularly useful here beyond making things deterministic
            since it compares completely different frameworks.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.CompatibilityCacheKey">
            <summary>
            Internal cache key used to store framework compatibility.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.CompatibilityProvider.IsCompatible(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Check if the frameworks are compatible.
            </summary>
            <param name="target">Project framework</param>
            <param name="candidate">Other framework to check against the project framework</param>
            <returns>True if framework supports other</returns>
        </member>
        <member name="M:NuGet.Frameworks.CompatibilityProvider.IsCompatibleCore(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Actual compatibility check without caching
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.CompatibilityProvider.GetEquivalentFrameworksClosure(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Find all equivalent frameworks, and their equivalent frameworks.
            Example:
            Mappings:
            A &lt;‒&gt; B
            B &lt;‒&gt; C
            C &lt;‒&gt; D
            For A we need to find B, C, and D so we must retrieve equivalent frameworks for A, B, and C
            also as we discover them.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.CompatibilityTable">
            <summary>
            Creates a table of compatible frameworks.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.CompatibilityTable.HasFramework(NuGet.Frameworks.NuGetFramework)">
            <summary>
            True if the framework is in the table.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.CompatibilityTable.GetNearest(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Gives the smallest set of frameworks from the table that cover everything the given framework would cover.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.CompatibilityTable.TryGetCompatible(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Returns the list of all frameworks compatible with the given framework
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.DefaultFrameworkMappings.Instance">
            <summary>
            Singleton instance of the default framework mappings.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.DefaultPortableFrameworkMappings">
            <summary>
            Contains the standard portable framework mappings
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.DefaultPortableFrameworkMappings.Instance">
            <summary>
            Static instance of the portable framework mappings
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkCompatibilityListProvider.GetFrameworksSupporting(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Get a list of frameworks supporting the provided framework. This list
            is not meant to be exhaustive but is instead meant to be human-readable.
            Ex: netstandard1.5 -&gt; netstandardapp1.5, net462, dnxcore50, ...
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkCompatibilityProvider.IsCompatible(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Ex: IsCompatible(net45, net40) -&gt; true
            Ex: IsCompatible(net40, net45) -&gt; false
            </summary>
            <param name="framework">Project target framework</param>
            <param name="other">Library framework that is going to be installed</param>
            <returns>True if framework supports other</returns>
        </member>
        <member name="T:NuGet.Frameworks.IFrameworkMappings">
            <summary>
            A raw list of framework mappings. These are indexed by the framework name provider and in most cases all
            mappings are
            mirrored so that the IFrameworkMappings implementation only needs to provide the minimum amount of
            mappings.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.IdentifierSynonyms">
            <summary>
            Synonym ‒&gt; Identifier
            Ex: NET Framework ‒&gt; .NET Framework
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.IdentifierShortNames">
            <summary>
            Ex: .NET Framework ‒&gt; net
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.ProfileShortNames">
            <summary>
            Ex: WindowsPhone ‒&gt; wp
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentFrameworks">
            <summary>
            Equal frameworks. Used for legacy conversions.
            ex: Framework: Win8 &lt;‒&gt; Framework: NetCore45 Platform: Win8
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentProfiles">
            <summary>
            Framework, EquivalentProfile1, EquivalentProfile2
            Ex: Silverlight, WindowsPhone71, WindowsPhone
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.SubSetFrameworks">
            <summary>
            Frameworks which are subsets of others.
            Ex: .NETCore ‒&gt; .NET
            Everything in .NETCore maps to .NET and is one way compatible. Version numbers follow the same format.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.CompatibilityMappings">
            <summary>
            Additional framework compatibility rules beyond name and version matching.
            Ex: .NETFramework supports ‒&gt; Native
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence">
            <summary>
            Ordered list of framework identifiers. The first framework in the list will be preferred over other 
            framework identifiers. This is enable better tie breaking in scenarios where legacy frameworks are 
            equivalently compatible to a new framework.
            Example: UAP10.0 ‒&gt; win81, wpa81
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.PackageBasedFrameworkPrecedence">
            <summary>
            Same as <see cref="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence" /> but is only referred to if all of the packages
            in consideration are package based (determined by <see cref="P:NuGet.Frameworks.NuGetFramework.IsPackageBased" />).
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentFrameworkPrecedence">
            <summary>
            Only used to choose between frameworks that are equivalent. This favors more human-readable target
            frameworks identifiers.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.ShortNameReplacements">
            <summary>
            Rewrite folder short names to the given value.
            Ex: dotnet50 ‒&gt; dotnet
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkMappings.FullNameReplacements">
            <summary>
            Rewrite full framework names to the given value.
            Ex: .NETPlatform,Version=v0.0 ‒&gt; .NETPlatform,Version=v5.0
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetIdentifier(System.String,System.String@)">
            <summary>
            Returns the official framework identifier for an alias or short name.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetShortIdentifier(System.String,System.String@)">
            <summary>
            Gives the short name used for folders in NuGet
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetProfile(System.String,System.String,System.String@)">
            <summary>
            Get the official profile name from the short name.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetShortProfile(System.String,System.String,System.String@)">
            <summary>
            Returns the shortened version of the profile name.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetVersion(System.String,System.Version@)">
            <summary>
            Parses a version string using single digit rules if no dots exist
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPlatformVersion(System.String,System.Version@)">
            <summary>
            Parses a version string. If no dots exist, all digits are treated
            as semver-major, instead of inserting dots.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetVersionString(System.String,System.Version)">
            <summary>
            Returns a shortened version. If all digits are single digits no dots will be used.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableProfileNumber(System.String,System.Int32@)">
            <summary>
            Tries to parse the portable profile number out of a profile.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableProfile(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Int32@)">
            <summary>
            Looks up the portable profile number based on the framework list.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.Int32,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Returns the frameworks based on a portable profile number.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Returns the frameworks based on a portable profile number.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.String,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Returns the frameworks based on a profile string.
            Profile can be either the number in format: Profile=7, or the shortened NuGet version: net45+win8
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.String,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Parses a shortened portable framework profile list.
            Ex: net45+win8
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableCompatibilityMappings(System.Int32,System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkRange}@)">
            <summary>
            Returns ranges of frameworks that are known to be supported by the given portable profile number.
            Ex: Profile7 -&gt; netstandard1.1
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Returns a list of all possible substitutions where the framework name
            have equivalents.
            Ex: sl3 -&gt; wp8
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.FrameworkRange,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
            <summary>
            Gives all substitutions for a framework range.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetCompatibilityMappings(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkRange}@)">
            <summary>
            Returns ranges of frameworks that are known to be supported by the given framework.
            Ex: net45 -&gt; native
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetSubSetFrameworks(System.String,System.Collections.Generic.IEnumerable{System.String}@)">
            <summary>
            Returns all sub sets of the given framework.
            Ex: .NETFramework -&gt; .NETCore
            These will have the same version, but a different framework
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.CompareFrameworks(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            The ascending order of frameworks should be based on the following ordered groups:
            
            1. Non-package-based frameworks in <see cref="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence" />.
            2. Other non-package-based frameworks.
            3. Package-based frameworks in <see cref="P:NuGet.Frameworks.IFrameworkMappings.PackageBasedFrameworkPrecedence" />.
            4. Other package-based frameworks.
            
            For group #1 and #3, the order within the group is based on the order of the respective precedence list.
            For group #2 and #4, the order is the original order in the incoming list. This should later be made
            consistent between different input orderings by using the <see cref="T:NuGet.Frameworks.NuGetFrameworkSorter" />.
            </summary>
            <remarks>netcore50 is a special case since netcore451 is not packages based, but netcore50 is.
            This sort will treat all versions of netcore as non-packages based.</remarks>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.CompareEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Used to pick between two equivalent frameworks. This is meant to favor the more human-readable
            framework. Note that this comparison does not validate that the provided frameworks are indeed
            equivalent (e.g. with
            <see cref="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)" />).
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetShortNameReplacement(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Returns folder short names rewrites.
            Ex: dotnet50 -&gt; dotnet
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetFullNameReplacement(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Returns full name rewrites.
            Ex: .NETPlatform,Version=v0.0 -&gt; .NETPlatform,Version=v5.0
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetNetStandardVersions">
            <summary>
            Returns all versions of .NETStandard in ascending order.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetCompatibleCandidates">
            <summary>
            Returns a list of frameworks that could be compatible with .NETStandard.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.IFrameworkSpecific">
            <summary>
            A group or object that is specific to a single target framework
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkSpecific.TargetFramework">
            <summary>
            Target framework
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.IFrameworkTargetable">
            <summary>
            Use this to expose the list of target frameworks an object can be used for.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IFrameworkTargetable.SupportedFrameworks">
            <summary>
            All frameworks supported by the parent
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.ProfileFrameworks">
            <summary>
            Ex: 5 -&gt; net4, win8
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.ProfileOptionalFrameworks">
            <summary>
            Additional optional frameworks supported in a portable profile.
            Ex: 5 -&gt; MonoAndroid1+MonoTouch1
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.CompatibilityMappings">
            <summary>
            Compatibility mapping for portable profiles. This is a separate compatibility from that in
            <see cref="P:NuGet.Frameworks.IFrameworkMappings.CompatibilityMappings" />.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.DualCompatibilityFramework">
            <summary>
            Represents a framework that behaves as 2 potentially independent frameworks.
            Ex. C++/CLI can support both .NET 5.0 and native.
            This type is immutable.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.DualCompatibilityFramework.RootFramework">
            <summary>
            The root framework. Any compatibility checks should be performed against this framework first.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.DualCompatibilityFramework.SecondaryFramework">
            <summary>
            The secondary framework. If the root framework compatibility checks fail, then the compat checks should be performed against this framework next.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.DualCompatibilityFramework.#ctor(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Multiple compatbility 
            </summary>
            <param name="framework">Root framework. Never <see langword="null" />. </param>
            <param name="secondaryFramework">Secondary framework. Never <see langword="null" />. </param>
            <exception cref="T:System.ArgumentNullException">if either <paramref name="framework" /> or <paramref name="secondaryFramework" /> are <see langword="null" />.</exception>
        </member>
        <member name="M:NuGet.Frameworks.DualCompatibilityFramework.AsFallbackFramework">
            <summary>
            Create a FallbackFramework from the current DualCompatibilityFramework.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.FallbackFramework.Fallback">
            <summary>
            List framework to fall back to.
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkConstants.CommonFrameworks">
            <summary>
            Interned frameworks that are commonly used in NuGet
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkExpander">
            <summary>
            FrameworkExpander finds all equivalent and compatible frameworks for a NuGetFramework
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkExpander.Expand(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Return all possible equivalent, subset, and known compatible frameworks.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkExpander.ExpandInternal(NuGet.Frameworks.NuGetFramework)">
            <summary>
            Finds all expansions using the mapping provider
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkExtensions.IsDesktop(NuGet.Frameworks.NuGetFramework)">
            <summary>
            True if the Framework is .NETFramework
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkExtensions.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework)">
            <summary>
            Return the item with the target framework nearest the project framework
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.FrameworkNameProvider.SingleDigitVersionFrameworks">
            <summary>
            Legacy frameworks that are allowed to have a single digit for the version number.
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.FrameworkNameProvider.DecimalPointFrameworks">
            <summary>
            Frameworks that must always include a decimal point (period) between numerical parts.
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.FrameworkNameProvider._identifierSynonyms">
            <summary>
            Contains identifier -&gt; identifier
            Ex: .NET Framework -&gt; .NET Framework
            Ex: NET Framework -&gt; .NET Framework
            This includes self mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkNameProvider.TryConvertOrNormalize(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.String@)">
            <summary>
            Converts a key using the mappings, or if the key is already converted, finds the normalized form.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkNameProvider.GetAllEquivalentFrameworks(NuGet.Frameworks.NuGetFramework)">
            <summary>  
            Get all equivalent frameworks including the given framework  
            </summary>  
        </member>
        <member name="M:NuGet.Frameworks.FrameworkNameProvider.AddEquivalentProfiles(System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkSpecificMapping})">
            <summary>
            2 way per framework profile equivalence
            </summary>
            <param name="mappings"></param>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkNameProvider.AddEquivalentFrameworks(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework}})">
            <summary>
            2 way framework equivalence
            </summary>
            <param name="mappings"></param>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkRange">
            <summary>
            An inclusive range of frameworks
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.FrameworkRange.Min">
            <summary>
            Minimum Framework
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.FrameworkRange.Max">
            <summary>
            Maximum Framework
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.FrameworkRange.IncludeMin">
            <summary>
            Minimum version inclusiveness.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.FrameworkRange.IncludeMax">
            <summary>
            Maximum version inclusiveness.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.FrameworkRange.FrameworkIdentifier">
            <summary>
            Framework Identifier of both the Min and Max
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkRange.Satisfies(NuGet.Frameworks.NuGetFramework)">
            <summary>
            True if the framework version falls between the min and max
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkReducer">
            <summary>
            Reduces a list of frameworks into the smallest set of frameworks required.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.#ctor">
            <summary>
            Creates a FrameworkReducer using the default framework mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.#ctor(NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
            <summary>
            Creates a FrameworkReducer using custom framework mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.GetNearest(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Returns the nearest matching framework that is compatible.
            </summary>
            <param name="framework">Project target framework</param>
            <param name="possibleFrameworks">Possible frameworks to narrow down</param>
            <returns>Nearest compatible framework. If no frameworks are compatible null is returned.</returns>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceEquivalent(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Remove duplicates found in the equivalence mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceUpwards(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Reduce to the highest framework
            Ex: net45, net403, net40 -&gt; net45
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceDownwards(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Reduce to the lowest framework
            Ex: net45, net403, net40 -&gt; net40
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.ExplodePortableFrameworks(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Create lookup of the given PCLs to their actual frameworks
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.ExplodePortableFramework(NuGet.Frameworks.NuGetFramework,System.Boolean)">
            <summary>
            portable-net45+win8 -&gt; net45, win8
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.GetBestPCL(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
            <summary>
            Order PCLs when there is no other way to decide.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.FrameworkReducer.IsBetterPCL(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Sort PCLs using these criteria
            1. Lowest number of frameworks (highest surface area) wins first
            2. Profile with the highest version numbers wins next
            3. String compare is used as a last resort
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkRuntimePair">
            <remarks>
            Immutable.
            </remarks>
        </member>
        <member name="T:NuGet.Frameworks.FrameworkSpecificMapping">
            <summary>
            A keyvalue pair specific to a framework identifier
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.NuGetFramework">
            <summary>
            A portable implementation of the .NET FrameworkName type with added support for NuGet folder names.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.#ctor(System.String,System.Version,System.String)">
            <summary>
            Creates a new NuGetFramework instance, with an optional profile (only available for netframework)
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.#ctor(System.String,System.Version,System.String,System.Version)">
            <summary>
            Creates a new NuGetFramework instance, with an optional platform and platformVersion (only available for net5.0+)
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.Framework">
            <summary>
            Target framework
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.Version">
            <summary>
            Target framework version
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.Platform">
            <summary>
            Framework Platform (net5.0+)
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.PlatformVersion">
            <summary>
            Framework Platform Version (net5.0+)
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.HasPlatform">
            <summary>
            True if the platform is non-empty
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.HasProfile">
            <summary>
            True if the profile is non-empty
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.Profile">
            <summary>
            Target framework profile
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.DotNetFrameworkName">
            <summary>The TargetFrameworkMoniker identifier of the current NuGetFramework.</summary>
            <remarks>Formatted to a System.Versioning.FrameworkName</remarks>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.GetDotNetFrameworkName(NuGet.Frameworks.IFrameworkNameProvider)">
            <summary>The TargetFrameworkMoniker identifier of the current NuGetFramework.</summary>
            <remarks>Formatted to a System.Versioning.FrameworkName</remarks>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.DotNetPlatformName">
            <summary>The TargetPlatformMoniker identifier of the current NuGetFramework.</summary>
            <remarks>Similar to a System.Versioning.FrameworkName, but missing the v at the beginning of the version.</remarks>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.GetShortFolderName">
            <summary>
            Creates the shortened version of the framework using the default mappings.
            Ex: net45
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.GetFrameworkIdentifier">
            <summary>
            Helper that is .NET 5 Era aware to replace identifier when appropriate
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.GetShortFolderName(NuGet.Frameworks.IFrameworkNameProvider)">
            <summary>
            Creates the shortened version of the framework using the given mappings.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsPCL">
            <summary>
            Portable class library check
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsPackageBased">
            <summary>
            True if the framework is packages based.
            Ex: dotnet, dnxcore, netcoreapp, netstandard, uap, netcore50
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.AllFrameworkVersions">
            <summary>
            True if this framework matches for all versions.
            Ex: net
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsUnsupported">
            <summary>
            True if this framework was invalid or unknown. This framework is only compatible with Any and Agnostic.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsAgnostic">
            <summary>
            True if this framework is non-specific. Always compatible.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsAny">
            <summary>
            True if this is the any framework. Always compatible.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsSpecificFramework">
            <summary>
            True if this framework is real and not one of the special identifiers.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.NuGetFramework.IsNet5Era">
            <summary>
            True if this framework is Net5 or later, until we invent something new.
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.NuGetFramework.Comparer">
            <summary>
            Full framework comparison of the identifier, version, profile, platform, and platform version
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.NuGetFramework.FrameworkNameComparer">
            <summary>
            Framework name only comparison.
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.NuGetFramework.PackagesBased">
            <summary>
            Frameworks that are packages based across all versions.
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.NuGetFramework.UnsupportedFramework">
            <summary>
            An unknown or invalid framework
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.NuGetFramework.AgnosticFramework">
            <summary>
            A framework with no specific target framework. This can be used for content only packages.
            </summary>
        </member>
        <member name="F:NuGet.Frameworks.NuGetFramework.AnyFramework">
            <summary>
            A wildcard matching all frameworks
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.Parse(System.String)">
            <summary>
            Creates a NuGetFramework from a folder name using the default mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.Parse(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
            <summary>
            Creates a NuGetFramework from a folder name using the given mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.ParseComponents(System.String,System.String)">
            <summary>
            Creates a NuGetFramework from individual components
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.ParseComponents(System.String,System.String,NuGet.Frameworks.IFrameworkNameProvider)">
            <summary>
            Creates a NuGetFramework from individual components, using the given mappings.
            This method may have individual component preference, as described in the remarks.
            </summary>
            <remarks>
            Profiles and TargetPlatforms can't mix. As such the precedence order is profile over target platforms (TPI, TPV).
            .NETCoreApp,Version=v5.0 and later do not support profiles.
            Target Platforms are ignored for any frameworks not supporting them.
            This allows to handle the old project scenarios where the TargetPlatformIdentifier and TargetPlatformVersion may be set to Windows and v7.0 respectively.
            </remarks>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.ParseFrameworkName(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
            <summary>
            Creates a NuGetFramework from a .NET FrameworkName
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.ParseFolder(System.String)">
            <summary>
            Creates a NuGetFramework from a folder name using the default mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.ParseFolder(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
            <summary>
            Creates a NuGetFramework from a folder name using the given mappings.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.TryParseDeprecatedFramework(System.String,NuGet.Frameworks.NuGetFramework@)">
            <summary>
            Attempt to parse a common but deprecated framework using an exact string match
            Support for these should be dropped as soon as possible.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFramework.TryParseCommonFramework(System.String,NuGet.Frameworks.NuGetFramework@)">
            <summary>
            A set of special and common frameworks that can be returned from the list of constants without parsing
            Using the interned frameworks here optimizes comparisons since they can be checked by reference.
            This is designed to optimize
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,System.Func{``0,NuGet.Frameworks.NuGetFramework})">
            <summary>
            Find the most compatible group based on target framework
            </summary>
            <param name="items">framework specific groups or items</param>
            <param name="framework">project target framework</param>
            <param name="selector">retrieves the framework from the group</param>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider,System.Func{``0,NuGet.Frameworks.NuGetFramework})">
            <summary>
            Find the most compatible group based on target framework
            </summary>
            <param name="items">framework specific groups or items</param>
            <param name="framework">project target framework</param>
            <param name="selector">retrieves the framework from the group</param>
            <param name="frameworkMappings">framework mappings</param>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework)">
            <summary>
            Find the most compatible group based on target framework
            </summary>
            <param name="items">framework specific groups or items</param>
            <param name="framework">project target framework</param>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
            <summary>
            Find the most compatible group based on target framework
            </summary>
            <param name="items">framework specific groups or items</param>
            <param name="framework">project target framework</param>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.IsCompatibleWithFallbackCheck(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
            <summary>
            Check compatibility with additional checks for the fallback framework.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.IsNetCore50AndUp(NuGet.Frameworks.NuGetFramework)">
            <summary>
            True if the framework is netcore50 or higher. This is where the framework
            becomes packages based.
            </summary>
        </member>
        <member name="M:NuGet.Frameworks.OneWayCompatibilityMappingEntry.#ctor(NuGet.Frameworks.FrameworkRange,NuGet.Frameworks.FrameworkRange)">
            <summary>
            Creates a one way compatibility mapping.
            Ex: net -supports-&gt; native
            </summary>
            <param name="targetFramework">Project framework</param>
            <param name="supportedFramework">Framework that is supported by the project framework</param>
        </member>
        <member name="P:NuGet.Frameworks.OneWayCompatibilityMappingEntry.TargetFrameworkRange">
            <summary>
            Primary framework range or project target framework that supports the SuppportedFrameworkRange
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.OneWayCompatibilityMappingEntry.SupportedFrameworkRange">
            <summary>
            Framework range that is supported by the TargetFrameworkRange
            </summary>
        </member>
        <member name="T:NuGet.Frameworks.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.ArgumentCannotBeNullOrEmpty">
            <summary>
              Looks up a localized string similar to The argument cannot be null or empty..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.FrameworkDoesNotSupportProfiles">
            <summary>
              Looks up a localized string similar to .NET 5.0 and above does not support profiles..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.FrameworkMismatch">
            <summary>
              Looks up a localized string similar to Frameworks must have the same identifier, profile, and platform..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.InvalidFrameworkIdentifier">
            <summary>
              Looks up a localized string similar to Invalid framework identifier '{0}'..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.InvalidFrameworkVersion">
            <summary>
              Looks up a localized string similar to Invalid framework version '{0}'..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.InvalidPlatformVersion">
            <summary>
              Looks up a localized string similar to Invalid platform version '{0}'..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.InvalidPortableFrameworksDueToHyphen">
            <summary>
              Looks up a localized string similar to Invalid portable frameworks '{0}'. A hyphen may not be in any of the portable framework names..
            </summary>
        </member>
        <member name="P:NuGet.Frameworks.Strings.MissingPortableFrameworks">
            <summary>
              Looks up a localized string similar to Invalid portable frameworks for '{0}'. A portable framework must have at least one framework in the profile..
            </summary>
        </member>
        <member name="T:NuGet.Shared.HashCodeCombiner">
            <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
        </member>
        <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode``2(``0,``1)">
            <summary>
            Create a unique hash code for the given set of items
            </summary>
        </member>
        <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
            <summary>
            Create a unique hash code for the given set of items
            </summary>
        </member>
        <member name="M:NuGet.Shared.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
            <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
        </member>
        <member name="M:NuGet.Shared.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
        </member>
        <member name="M:NuGet.Shared.Extensions.AppendInt(System.Text.StringBuilder,System.Int32)">
             <summary>
             Helper function to append an <see cref="T:System.Int32" /> to a <see cref="T:System.Text.StringBuilder" />. Calling
             <see cref="M:System.Text.StringBuilder.Append(System.Int32)" /> directly causes an allocation by first converting the
             <see cref="T:System.Int32" /> to a string and then appending that result:
             <code>
             public StringBuilder Append(int value)
             {
                 return Append(value.ToString(CultureInfo.CurrentCulture));
             }
             </code>
            
             Note that this uses the current culture to do the conversion while <see cref="M:NuGet.Shared.Extensions.AppendInt(System.Text.StringBuilder,System.Int32)" /> does
             not do any cultural sensitive conversion.
             </summary>
             <param name="sb">The <see cref="T:System.Text.StringBuilder" /> to append to.</param>
             <param name="value">The <see cref="T:System.Int32" /> to append.</param>
        </member>
        <member name="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IList{``0})">
             <summary>
             Avoids allocating an enumerator when enumerating an <see cref="T:System.Collections.Generic.IList`1" />.
             </summary>
             <remarks>
             <para>
             Returns a struct-based enumerator that avoids heap allocation during enumeration.
             If the underlying type is <see cref="T:System.Collections.Generic.List`1" /> then this method will delegate to <see cref="T:System.Collections.Generic.List`1.Enumerator" />,
             otherwise the collection's items are accessed by index via <see cref="T:System.Collections.Generic.IList`1" />'s indexer directly.
             </para>
             <para>
             When using a struct-based enumerator, no heap allocation occurs during enumeration via <see langword="foreach" />.
             This is in contrast to the interface-based enumerator <see cref="T:System.Collections.Generic.IEnumerator`1" /> which will
             always be allocated on the heap.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[IList<string> list = ...;
            
             foreach (string item in list.NoAllocEnumerate())
             {
                 // ...
             }]]>
             </code>
             </example>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingListEnumerable`1">
            <summary>
            Provides a struct-based enumerator for use with <see cref="T:System.Collections.Generic.IList`1" />.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IList{``0})" /> instead.
            </summary>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingListEnumerable`1.Enumerator">
            <summary>
            A struct-based enumerator for use with <see cref="T:System.Collections.Generic.IList`1" />.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IList{``0})" /> instead.
            </summary>
        </member>
        <member name="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IEnumerable{``0})">
             <summary>
             Avoids allocating an enumerator when enumerating an <see cref="T:System.Collections.Generic.IEnumerable`1" /> where the concrete type
             has a well known struct enumerator, such as for <see cref="T:System.Collections.Generic.List`1" />, or when index-based access is possible via
             <see cref="T:System.Collections.Generic.IList`1" />.
             </summary>
             <remarks>
             <para>
             Several collection types (e.g. <see cref="T:System.Collections.Generic.List`1" />) provide a struct-based enumerator type
             (e.g. <see cref="T:System.Collections.Generic.List`1.Enumerator" />) which the compiler can use in <see langword="foreach" /> statements.
             When using a struct-based enumerator, no heap allocation occurs during such enumeration.
             This is in contrast to the interface-based enumerator <see cref="T:System.Collections.Generic.IEnumerator`1" /> which will
             always be allocated on the heap.
             </para>
             <para>
             This method returns a custom struct enumerator that will avoid any heap allocation if <paramref name="source" />
             (which is declared via interface <see cref="T:System.Collections.Generic.IEnumerable`1" />) is actually of known concrete type that
             provides its own struct enumerator. If so, it delegates to that type's enumerator without any boxing
             or other heap allocation.
             </para>
             <para>
             If <paramref name="source" /> is not of a known concrete type, the returned enumerator falls back to the
             interface-based enumerator, which will be allocated on the heap. Benchmarking shows the overhead in
             such cases is low enough to be within the measurement error, meaning this is an inexpensive optimization
             that won't regress behavior and with low downside for cases where it cannot apply an optimization.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[IEnumerable<string> source = ...;
            
             foreach (string item in source.NoAllocEnumerate())
             {
                 // ...
             }]]>
             </code>
             </example>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingEnumerable`1">
            <summary>
            Provides a struct-based enumerator for use with <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IEnumerable{``0})" /> instead.
            </summary>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingEnumerable`1.Enumerator">
            <summary>
            A struct-based enumerator for use with <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``1(System.Collections.Generic.IEnumerable{``0})" /> instead.
            </summary>
        </member>
        <member name="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``2(System.Collections.Generic.IDictionary{``0,``1})">
             <summary>
             Avoids allocating an enumerator when enumerating an <see cref="T:System.Collections.Generic.IDictionary`2" /> where the concrete type
             has a well known struct enumerator, such as for <see cref="T:System.Collections.Generic.Dictionary`2" />.
             </summary>
             <remarks>
             <para>
             Several collection types (e.g. <see cref="T:System.Collections.Generic.Dictionary`2" />) provide a struct-based enumerator type
             (e.g. <see cref="T:System.Collections.Generic.Dictionary`2.Enumerator" />) which the compiler can use in <see langword="foreach" /> statements.
             When using a struct-based enumerator, no heap allocation occurs during such enumeration.
             This is in contrast to the interface-based enumerator <see cref="T:System.Collections.Generic.IEnumerator`1" /> which will
             always be allocated on the heap.
             </para>
             <para>
             This method returns a custom struct enumerator that will avoid any heap allocation if <paramref name="dictionary" />
             (which is declared via interface <see cref="T:System.Collections.Generic.IEnumerable`1" />) is actually of known concrete type that
             provides its own struct enumerator. If so, it delegates to that type's enumerator without any boxing
             or other heap allocation.
             </para>
             <para>
             If <paramref name="dictionary" /> is not of a known concrete type, the returned enumerator falls back to the
             interface-based enumerator, which will be allocated on the heap. Benchmarking shows the overhead in
             such cases is low enough to be within the measurement error, meaning this is an inexpensive optimization
             that won't regress behavior and with low downside for cases where it cannot apply an optimization.
             </para>
             </remarks>
             <example>
             <code>
             <![CDATA[IDictionary<string, string> dictionary = ...;
            
             foreach ((string key, string value) in dictionary.NoAllocEnumerate())
             {
                 // ...
             }]]>
             </code>
             </example>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingDictionaryEnumerable`2">
            <summary>
            Provides a struct-based enumerator for use with <see cref="T:System.Collections.Generic.IDictionary`2" />.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``2(System.Collections.Generic.IDictionary{``0,``1})" /> instead.
            </summary>
        </member>
        <member name="T:NuGet.NoAllocEnumerateExtensions.OptimisticallyNonAllocatingDictionaryEnumerable`2.Enumerator">
            <summary>
            A struct-based enumerator for use with <see cref="T:System.Collections.Generic.IEnumerable`1" />.
            Do not use this type directly. Use <see cref="M:NuGet.NoAllocEnumerateExtensions.NoAllocEnumerate``2(System.Collections.Generic.IDictionary{``0,``1})" /> instead.
            </summary>
        </member>
        <member name="T:NuGet.StringBuilderPool">
            <summary>
            Provides a resource pool that enables reusing instances of <see cref="T:System.Text.StringBuilder" /> instances.
            </summary>
            <remarks>
            <para>
            Renting and returning buffers with an <see cref="T:NuGet.StringBuilderPool" /> can increase performance
            in situations where <see cref="T:System.Text.StringBuilder" /> instances are created and destroyed frequently,
            resulting in significant memory pressure on the garbage collector.
            </para>
            <para>
            This class is thread-safe.  All members may be used by multiple threads concurrently.
            </para>
            </remarks>
        </member>
        <member name="F:NuGet.StringBuilderPool.Shared">
            <summary>
            Retrieves a shared <see cref="T:NuGet.StringBuilderPool" /> instance.
            </summary>
        </member>
        <member name="M:NuGet.StringBuilderPool.Rent(System.Int32)">
            <summary>
            Retrieves a <see cref="T:System.Text.StringBuilder" /> that is at least the requested length.
            </summary>
            <param name="minimumCapacity">The minimum capacity of the <see cref="T:System.Text.StringBuilder" /> needed.</param>
            <returns>
            A <see cref="T:System.Text.StringBuilder" /> that is at least <paramref name="minimumCapacity" /> in length.
            </returns>
            <remarks>
            This buffer is loaned to the caller and should be returned to the same pool via
            <see cref="M:NuGet.StringBuilderPool.ToStringAndReturn(System.Text.StringBuilder)" /> so that it may be reused in subsequent usage of <see cref="M:NuGet.StringBuilderPool.Rent(System.Int32)" />.
            It is not a fatal error to not return a rented string builder, but failure to do so may lead to
            decreased application performance, as the pool may need to create a new instance to replace
            the one lost.
            </remarks>
        </member>
        <member name="M:NuGet.StringBuilderPool.ToStringAndReturn(System.Text.StringBuilder)">
            <summary>
            Returns to the pool an array that was previously obtained via <see cref="M:NuGet.StringBuilderPool.Rent(System.Int32)" /> on the same
            <see cref="T:NuGet.StringBuilderPool" /> instance, returning the built string.
            </summary>
            <param name="builder">
            The <see cref="T:System.Text.StringBuilder" /> previously obtained from <see cref="M:NuGet.StringBuilderPool.Rent(System.Int32)" /> to return to the pool.
            </param>
            <remarks>
            Once a <see cref="T:System.Text.StringBuilder" /> has been returned to the pool, the caller gives up all ownership
            of the instance and must not use it. The reference returned from a given call to <see cref="M:NuGet.StringBuilderPool.Rent(System.Int32)" />
            must only be returned via <see cref="M:NuGet.StringBuilderPool.ToStringAndReturn(System.Text.StringBuilder)" /> once.  The default <see cref="T:NuGet.StringBuilderPool" />
            may hold onto the returned instance in order to rent it again, or it may release the returned instance
            if it's determined that the pool already has enough instances stored.
            </remarks>
            <returns>The string, built from <paramref name="builder" />.</returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue" />, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue" />, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
    </members>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /><SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256" /><DigestValue>rWLEYE4Eh/m1gwXLra2TUa32AJOOl6xW8R3uUd2qXEQ=</DigestValue></Reference></SignedInfo><SignatureValue>KwNfvhu6qb4zPBDcn1JSFnkpig/kT78My3Txvc+jQM1Oc1yI7ze8vEK8QHqyHk6Lq9jqPIgqMZqZ50GMJEWFowUdRD7wOjzFC7b4QY57JXLC1nqRLh3DN5OlLIuxQnW0ZCNPkrmEemsPwIk8CNRFTW56lC7376ukWzcPa76NoOdAl+TWMaEAUrNAgXqR8n+i0hok2nzv/2gkdsaOX27Qy6wuwIRjmsQXqzr6XTTbiOrB5RN2lOt2/YYVZ3c5InZ/QFawbSmja35SwEOPKnbSz1nNyAA7Ebk8/9sonZsviMW431U9pv3C06CsHxFAvQ4Uba5VqE/lH6n9AtdsPQkP4g==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>tCg32mOdDA6rBBnZSMwxwXegqiDEUFlvQH9Sxww07hY3w7L52tJxLg0mCZjcszQddI6W4NJYb5E9QM319kyyE0l8EvA/pgcxgljDP8E6XIlgVf6W40ms286Cr0azaA1f7vaJjjNhGsMqOSSSXTZDNnfKs5ENG0bkXeB2q5hrp0qLsm/TWO3oFjeROZVHN2tgETswHR3WKTm6QjnXgGNj+V6rSZJO/WkTqc8NesAo3Up/KjMwgc0e67x9llZLxRyyMWUBE9coT2+pUZqYAUDZ84nR1djnMY3PMDYiA84Gw5JpceeED38O0cEIvKdX8uG8oQa047+evMfDRr94MG9EWw==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><X509Data><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate></X509Data></KeyInfo><Object Id="ts-countersig"><X509Data><X509Certificate>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</X509Certificate><X509Certificate>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</X509Certificate></X509Data><CounterSignature ts-format="cms-timestamp-message" xmlns="http://schemas.microsoft.com/xmldsig/timestamp/2003">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</CounterSignature></Object></Signature></doc>
